// PLC - Adrian Gonzalez Leiva
import java_cup.runtime.*;

// Code available in the grammar actions
action code {:
	Printer printer = new Printer();	        // Variable for printing
	SymbolTable symTable = new SymbolTable();   // Symbol table
	int actualScope = 0;                        // Aux variable for scope
:}

// Override error reporting method
parser code {:
    @Override
    public void report_error(String message, Object info){ // Syntax error handling message
        new Printer().error(message);
    }
:}

/* Terminals */
terminal            	MAS, MENOS, POR, DIV, MOD, UMINUS, INCR, DECR, PREINCR;
terminal            	AP, CP, ALL, CLL;
terminal            	ASIG, PYC, COMA;
terminal				EQ, NEQ, LOW, LOE, GRE, GOE;
terminal				NOT, AND, OR;
terminal				ELSE, PRINT, STEP;
terminal                INT;
terminal String			IF, WHILE, DO, FOR,TO, DOWNTO;
terminal Integer    	ENTERO;
terminal String     	IDENT;

/* Non terminals */
non terminal         	sent, listaSent;
non terminal         	decl, listaDecl;
non terminal            whileLoop, doWhileLoop, forLoop, forPascal;
non terminal            forTo, forDownTo;
non terminal			ifElseSent, elsePart;
non terminal String     incrDecrOp;
non terminal Condition	cond;
non terminal Object 	exp, prePostIncrDecr, stepPart;

/* Precedence */
precedence left         COMA;
precedence right        ASIG;
precedence left         OR;
precedence left         AND;
precedence left         EQ, NEQ;
precedence left         LOW, LOE, GRE, GOE;
precedence left         MAS, MENOS;
precedence left         POR, DIV, MOD;
precedence right        UMINUS, PREINCR;
precedence left         INCR, DECR;
precedence left         ELSE;

/* Grammar */
listaSent ::= sent      
            | listaSent sent 
            ;

sent ::= exp:e PYC
       | ifElseSent                 {: :}
       | whileLoop                  {: :}
       | doWhileLoop                {: :}
       | forLoop                    {: :}
       | forPascal                  {: :}
        // PRINT
       | PRINT AP exp:e1 CP PYC		{: printer.print(e1); :}
        // Anonymous block
       | ALL                        {: actualScope++; :}
         listaSent CLL		        {: symTable.purge(actualScope--); :}
        // Declarations
       | INT listaDecl PYC          {:  :}
       ;

listaDecl ::= listaDecl COMA decl   {:  :}
            | decl                  {:  :}
            ;

decl ::= IDENT:i                    {: symTable.declare(i, actualScope); :}
       | IDENT:i ASIG exp:e         {: symTable.declare(i, actualScope); printer.assignment(symTable.lookUp(i), e); :}
       ;

exp ::= exp:e1 MAS exp:e2		    {: RESULT = printer.tern(e1 + " + " + e2); :}
      | exp:e1 MENOS exp:e2   		{: RESULT = printer.tern(e1 + " - " + e2); :}
      | exp:e1 POR exp:e2     		{: RESULT = printer.tern(e1 + " * " + e2); :}
      | exp:e1 DIV exp:e2     		{: RESULT = printer.tern(e1 + " / " + e2); :}
      | exp:e1 MOD exp:e2     		{: RESULT = printer.mod(e1,e2); :}
      | MENOS exp:e1          		{: RESULT = printer.tern("0 - " + e1); :}  %prec UMINUS
      | AP exp:e1 CP          		{: RESULT = e1; :}
      | IDENT:i ASIG exp:e1 		{: RESULT = printer.assignment(symTable.lookUp(i), e1); :}
      | IDENT:i				        {: RESULT = symTable.lookUp(i); :}
      | ENTERO:n              		{: RESULT = n; :}
      | prePostIncrDecr:n           {: RESULT = n; :}
      ;

prePostIncrDecr ::= incrDecrOp:op IDENT:i       {: RESULT = printer.preIncrDecr(symTable.lookUp(i), op); :} %prec PREINCR
                  | IDENT:i incrDecrOp:op       {: RESULT = printer.postIncrDecr(symTable.lookUp(i), op); :}
                  | error                       {:  :}
                  ;

incrDecrOp ::= INCR					{: RESULT = "++"; :}
		     | DECR					{: RESULT = "--"; :}
		     ;

cond ::= exp:e1 EQ exp:e2		    {: RESULT = printer.condition(e1, Condition.EQ, e2); :}
       | exp:e1 NEQ exp:e2		    {: RESULT = printer.condition(e1, Condition.NEQ, e2); :}
       | exp:e1 LOW exp:e2		    {: RESULT = printer.condition(e1, Condition.LOW, e2); :}
       | exp:e1 LOE exp:e2		    {: RESULT = printer.condition(e1, Condition.LOE, e2); :}
       | exp:e1 GRE exp:e2		    {: RESULT = printer.condition(e1, Condition.GRE, e2); :}
       | exp:e1 GOE exp:e2		    {: RESULT = printer.condition(e1, Condition.GOE, e2); :}
       | NOT cond:c1			    {: RESULT = new Condition();
					                   RESULT.trueTag = c1.falseTag;
					                   RESULT.falseTag = c1.trueTag;
					                :}
       | cond:c1 AND 			    {: printer.label(c1.trueTag); :}
	     cond:c2  			        {: printer.label(c1.falseTag);
					                   printer.goTo(c2.trueTag);
					                   RESULT = c2;
					                :}
       | cond:c1 OR			        {: printer.label(c1.falseTag); :}
 	     cond:c2  			        {: printer.label(c1.trueTag);
					                   printer.goTo(c2.falseTag);
					                   RESULT = c2;
					                :}
       | AP cond:c1 CP			    {: RESULT = c1; :}
       ;


// LOOPS and FLOW CONTROLS

    // IF [ELSE]
ifElseSent ::= IF:endIf             {: :}
               AP cond:c CP		    {: printer.label(c.trueTag); :}
               sent				    {: printer.goTo(endIf);
					   				   printer.label(c.falseTag);
									:}
               elsePart             {: printer.label(endIf); :}
               ;

elsePart ::= ELSE sent
       |
       ;

    // WHILE loop
whileLoop ::= WHILE:whileTag		{: printer.label(whileTag); :}
              AP cond:c CP   		{: printer.label(c.falseTag); :}
              sent				    {: printer.goTo(whileTag);
                                       printer.goTo(c.trueTag);
                                    :}
                ;

    // DO WHILE
doWhileLoop ::= DO:doTag       		{: printer.label(doTag); :}
                sent                {: :}
                WHILE AP cond:c CP  {: :}
                PYC		            {: printer.label(c.trueTag);
                                       printer.goTo(doTag);
                                       printer.label(c.falseTag);
                                    :}
                ;

    // FOR loop
forLoop ::= FOR:forTag
	        AP exp:e1			    {: printer.label(forTag); :}
	        PYC cond:c PYC			{: RESULT = Yylex.newTag();
					                   printer.label(RESULT.toString());
                                    :}
	        exp:e2				    {: printer.goTo(forTag);
					                   printer.label(c.trueTag);
					                :}
	        CP sent			        {: printer.goTo(RESULT.toString());
					                   printer.label(c.falseTag);
					                :}
            ;

    // FOR TO/DOWN TO (pascal)
forPascal ::= forTo                 {: :}
            | forDownTo             {: :}
            ;

    // FOR TO [step]
forTo ::= FOR:forTag exp:e1         {: :}
          TO:toTag exp:e2           {: printer.label(forTag);
                                       RESULT = printer.condition(e2, Condition.LOW, e1);
                                       printer.label(toTag);
                                    :}
          stepPart:s DO             {: printer.raw(e1 + " = " + e1 + " + " + ((s == null) ? "1" : s) + ";");
                                       printer.goTo(forTag);
                                       printer.label(((Condition) RESULT).falseTag);
                                    :}
          ALL listaSent CLL         {: printer.goTo(toTag);
                                       printer.label(((Condition) RESULT).trueTag);
                                    :}
          ;

    // FOR DOWNTO [step]
forTo ::= FOR:forTag exp:e1         {: :}
          DOWNTO:toTag exp:e2       {: printer.label(forTag);
                                       RESULT = printer.condition(e1, Condition.LOW, e2);
                                       printer.label(toTag);
                                    :}
          stepPart:s DO             {:
                                       printer.raw(e1 + " = " + e1 + " - " + ((s == null) ? "1" : s) + ";");
                                       printer.goTo(forTag);
                                       printer.label(((Condition) RESULT).falseTag);
                                    :}
          ALL listaSent CLL         {: printer.goTo(toTag);
                                       printer.label(((Condition) RESULT).trueTag);
                                    :}
          ;

stepPart ::= STEP exp:e             {: RESULT = e; :}
           |                        {: RESULT = null; :}
           ;