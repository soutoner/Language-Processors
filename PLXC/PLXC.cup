// PLXC - Adrian Gonzalez Leiva
import java_cup.runtime.*;

// Code available in the grammar actions
action code {:
	SymbolTable variables = new SymbolTable();	    // Variables set
	int actualScope = 0;							// actual scope of the variables
	Condition forTo;								// aux variable for forto and for-downto conditions
:}

/*Terminals */
terminal            MAS, MENOS, POR, DIV, MOD, UMINUS, INCR, DECR, PREINCR;
terminal            AP, CP, ALL, CLL;
terminal            ASIG, PYC, COMMA;
terminal			EQ, NEQ, LOW, LOE, GRE, GOE;
terminal			NOT, AND, OR;
terminal			ELSE, PRINT, INT, STEP;
terminal String		IF, WHILE, DO, FOR, TO, DOWNTO;
terminal Integer    ENTERO;
terminal String     IDENT;

/* Non terminals */
non terminal         	lista_sent;
non terminal         	sent;
non terminal		 	else_part, ident_list, step_part;
non terminal Condition	cond;
non terminal String 	exp, incrop, assig;

/* Precedence */
precedence left  COMMA;
precedence right ASIG;
precedence left  OR;
precedence left  AND;
precedence left  EQ, NEQ;
precedence left  LOW, LOE, GRE, GOE;
precedence left  MAS, MENOS;
precedence left  POR, DIV, MOD;
precedence right UMINUS, PREINCR;
precedence left  INCR, DECR;
precedence left  ELSE;

/* Grammar */
lista_sent	::= sent      
              | lista_sent sent 
              ;

sent	::= exp:e PYC
			// IF - ELSE (opt)
		  | IF:endIf AP cond:c CP 					{: Printer.label(c.trueTag); :}
			sent				 					{: Printer.goTo(endIf);
													   Printer.label(c.falseTag);													
													:}
			else_part								{: Printer.label(endIf); :}
			// WHILE LOOP
		  | WHILE:whileTag					       	{: Printer.label(whileTag); :}
			AP cond:c CP							{: Printer.label(c.falseTag); :}
			sent									{: Printer.goTo(whileTag);
													   Printer.goTo(c.trueTag);													
													:}
			// DO - WHILE
		  | DO:doTag 								{: Printer.label(doTag); :}
			sent 
			WHILE AP cond:c CP PYC					{: Printer.label(c.trueTag);
													   Printer.goTo(doTag);
													   Printer.label(c.falseTag);
													:}
			// FOR LOOP
		  | FOR:forTag								
			AP exp:e1								{: Printer.label(forTag); :}
			PYC cond:c PYC							{: RESULT = Yylex.newTag();
													   Printer.label(RESULT.toString());													
													:}
			exp:e2									{: Printer.goTo(forTag);
													   Printer.label(c.trueTag);
													:}
			CP sent									{: Printer.goTo(RESULT.toString());
													   Printer.label(c.falseTag);
													:} 
			// FOR TO [STEP] (pascal)
		  | FOR:forTag assig:a TO:toTag exp:e1		{: Printer.label(forTag);
													   forTo = Printer.condition(e1, Condition.LOW, a);
													   Printer.label(toTag);
													:}
			step_part:step DO						{: if(step != null) Printer.raw("   " + a + " = " + a + " + " + step + ";"); 
													   else Printer.raw("   " + a + " = " + a + " + 1;");
													   Printer.goTo(forTag);
													   Printer.label(forTo.falseTag);
													:} 
			ALL lista_sent CLL						{: Printer.goTo(toTag);
													   Printer.label(forTo.trueTag);
													:}
			// FOR DOWNTO [STEP] (pascal)
		  | FOR:forTag assig:a DOWNTO:toTag exp:e1  {: Printer.label(forTag);
													   forTo = Printer.condition(a, Condition.LOW, e1);
													   Printer.label(toTag);
													:}
			step_part:step DO						{: if(step != null) Printer.raw("   " + a + " = " + a + " - " + step + ";"); 
													   else Printer.raw("   " + a + " = " + a + " - 1;");
													   Printer.goTo(forTag);
													   Printer.label(forTo.falseTag);
													:} 
			ALL lista_sent CLL						{: Printer.goTo(toTag);
													   Printer.label(forTo.trueTag);
													:}
			// PRINT
		  | PRINT AP exp:e1 CP PYC					{: Printer.print(e1); :}
			// Anonymous block
		  | ALL 									{: actualScope++; :}
			lista_sent
			CLL										{: variables.purge(actualScope--); :}  
			// INT Declarations         
		  | INT ident_list PYC						{:  :}
          ;

			// ELSE optional part
else_part ::= ELSE sent
		    |
		    ;
			
			// STEP optional part
step_part ::= STEP exp:e							{: RESULT = e; :}
			|										
			;
			
			// Declarations and multiple declarations
ident_list ::= ident_list COMMA IDENT:i				{: variables.declare(i, actualScope); :}
			 | ident_list COMMA IDENT:i				{: variables.declare(i, actualScope); :}
			   ASIG exp:e1							{: Printer.assignment(i, e1); :}
			 | IDENT:i								{: variables.declare(i, actualScope); :}
			 | IDENT:i 								{: variables.declare(i, actualScope); :}
			   ASIG exp:e1							{: Printer.assignment(i, e1); :}
			 ;
			
		// Expressions
exp		::= exp:e1 MAS exp:e2		{: RESULT = Printer.tern(e1 + " + " + e2); :}
   	      | exp:e1 MENOS exp:e2   	{: RESULT = Printer.tern(e1 + " - " + e2); :}
          | exp:e1 POR exp:e2     	{: RESULT = Printer.tern(e1 + " * " + e2); :}
          | exp:e1 DIV exp:e2     	{: RESULT = Printer.tern(e1 + " / " + e2); :}
          | exp:e1 MOD exp:e2     	{: RESULT = Printer.mod(e1, e2); :}
	      | MENOS exp:e1          	{: RESULT = Printer.tern("0 - " + e1); :}  %prec UMINUS
          | AP exp:e1 CP          	{: RESULT = e1; :}
		  | assig:a 				{: RESULT = a; :}
		  | IDENT:i				  	{: RESULT = variables.lookUp(i, actualScope); :}
	      | ENTERO:n              	{: RESULT = n.toString(); :}
		  | incrop:op exp:e	    	{: RESULT = Printer.preIncr(e, op); :} %prec PREINCR
		  | exp:e incrop:op			{: RESULT = Printer.postIncr(e, op); :}
		  ;

		// Assignation (not declaration)
assig	::= IDENT:i ASIG exp:e1 	{: RESULT = Printer.assignment(variables.lookUp(i, actualScope), e1); :}
		  ;
			
		// Increment or decrement
incrop 	::= INCR					{: RESULT = "++"; :}
		  | DECR					{: RESULT = "--"; :}
		  ;
		
		// Boolean conditions
cond	::= exp:e1 EQ exp:e2		{: RESULT = Printer.condition(e1, Condition.EQ, e2); :}
		  | exp:e1 NEQ exp:e2		{: RESULT = Printer.condition(e1, Condition.NEQ, e2); :}
		  | exp:e1 LOW exp:e2		{: RESULT = Printer.condition(e1, Condition.LOW, e2); :} 
		  | exp:e1 LOE exp:e2		{: RESULT = Printer.condition(e1, Condition.LOE, e2); :}
		  | exp:e1 GRE exp:e2		{: RESULT = Printer.condition(e1, Condition.GRE, e2); :}
		  | exp:e1 GOE exp:e2		{: RESULT = Printer.condition(e1, Condition.GOE, e2); :}
		  | NOT cond:c1				{: RESULT = c1.not(); :}
		  | cond:c1 AND 			{: Printer.label(c1.trueTag); :}
			cond:c2		  			{: Printer.label(c1.falseTag);
									   Printer.goTo(c2.trueTag);
									   RESULT = c2;									
									:}
		  | cond:c1 OR 				{: Printer.label(c1.falseTag); :}
			cond:c2		  			{: Printer.label(c1.trueTag);
									   Printer.goTo(c2.falseTag);
									   RESULT = c2;									
									:}
		  | AP cond:c1 CP			{: RESULT = c1; :}
		  ;
