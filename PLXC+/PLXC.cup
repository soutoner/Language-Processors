// PLC - Adrian Gonzalez Leiva
import java_cup.runtime.*;
import java.util.*;

// Code available in the grammar actions
action code {:
    SymbolTable symTable = new SymbolTable();       // Symbol table
    Printer printer = new Printer(symTable);        // Variable for printing
	int actualScope = 0;                            // Aux variable for scope
:}

// Override error reporting method
parser code {:
    @Override
    public void report_error(String message, Object info){ // Syntax error handling message
        new Printer().error(message);
    }
:}

/* Terminals */
terminal            	MAS, MENOS, POR, DIV, MOD, UMINUS, INCR, DECR, PREINCR;
terminal            	AP, CP, ALL, CLL, AC, CC;
terminal            	ASIG, PYC, COMA;
terminal				EQ, NEQ, LOW, LOE, GRE, GOE;
terminal				NOT, AND, OR;
terminal				ELSE, PRINT, IN;
terminal                INT, FLOAT;
terminal String			IF, WHILE, DO, FOR;
terminal String     	IDENT;
terminal Integer    	ENTERO;
terminal Double    	    REAL;

/* Non terminals */
non terminal         	    sent, listaSent;
non terminal         	    declaSent, declInt, listaDeclInt, declFloat, listaDeclFloat;
non terminal                whileLoop, doWhileLoop, forLoop, forIn;
non terminal			    ifElseSent, elsePart;
non terminal String         incrDecrOp, variable;
non terminal Condition	    cond;
non terminal Object         exp, number, varOrNumber;
non terminal Object 	    prePostIncrDecr, assignment, casting, arrayPart;
non terminal List<Object>   listaExp;

/* Precedence */
precedence left         COMA;
precedence right        ASIG;
precedence left         OR;
precedence left         AND;
precedence left         EQ, NEQ;
precedence left         LOW, LOE, GRE, GOE;
precedence left         MAS, MENOS;
precedence left         POR, DIV, MOD;
precedence right        UMINUS, PREINCR;
precedence left         INCR, DECR;
precedence left         ELSE;

/* Grammar */
listaSent ::= sent      
            | listaSent sent 
            ;

sent ::= exp:e PYC                       {: :}
       | ifElseSent                      {: :}
       | whileLoop                       {: :}
       | doWhileLoop                     {: :}
       | forLoop                         {: :}
       | forIn                           {: :}
       | declaSent                       {: :}
        // PRINT
       | PRINT AP exp:e1 CP PYC		     {: printer.print(e1); :}
        // Anonymous block
       | ALL                             {: actualScope++; :}
         listaSent CLL		             {: symTable.purge(actualScope--); :}
       ;

    // DECLARATIONS
declaSent ::= INT listaDeclInt PYC       {: :}
            | FLOAT listaDeclFloat PYC   {: :}
            ;

    // INT declarations
listaDeclInt ::= listaDeclInt COMA declInt  {: :}
               | declInt                    {: :}
               ;

declInt ::= IDENT:i                     {: symTable.declare(i, actualScope, Occurrence.INT); :}
          | IDENT:i ASIG exp:e          {: symTable.declare(i, actualScope, Occurrence.INT); printer.assignment(symTable.lookUp(i), e); :}
          | IDENT:i AC ENTERO:size CC   {: symTable.declare(i, actualScope, Occurrence.INT, size);:}
          | IDENT:i AC ENTERO:size CC   {: symTable.declare(i, actualScope, Occurrence.INT, size); :}
            ASIG ALL listaExp:l CLL     {: printer.arrayInit(i, l); :}
          ;

listaExp ::= listaExp:l COMA exp:e      {: l.add(e); RESULT = l; :}
           | exp:e                      {: RESULT = new ArrayList<Object>(); RESULT.add(e); :}
           ;

    // FLOAT declarations
listaDeclFloat ::= listaDeclFloat COMA declFloat    {: :}
                 | declFloat                        {: :}
                 ;

declFloat ::= IDENT:i                       {: symTable.declare(i, actualScope, Occurrence.FLOAT); :}
            | IDENT:i ASIG exp:e            {: symTable.declare(i, actualScope, Occurrence.FLOAT); printer.assignment(symTable.lookUp(i), e); :}
            | IDENT:i AC ENTERO:size CC     {: symTable.declare(i, actualScope, Occurrence.FLOAT, size); :}
            | IDENT:i AC ENTERO:size CC     {: symTable.declare(i, actualScope, Occurrence.FLOAT, size); :}
              ASIG ALL listaExp:l CLL       {: printer.arrayInit(i, l); :}
            ;

exp ::= exp:e1 MAS exp:e2		        {: RESULT = printer.tern(e1, Printer.ADD, e2); :}
      | exp:e1 MENOS exp:e2   		    {: RESULT = printer.tern(e1, Printer.SUB, e2); :}
      | exp:e1 POR exp:e2     		    {: RESULT = printer.tern(e1, Printer.MUL, e2); :}
      | exp:e1 DIV exp:e2     		    {: RESULT = printer.tern(e1, Printer.DIV, e2); :}
      | exp:e1 MOD exp:e2     		    {: RESULT = printer.mod(e1,e2); :}
      | MENOS exp:e          		    {: RESULT = printer.tern(new Integer(0), Printer.SUB, e); :}  %prec UMINUS
      | AP exp:e CP          		    {: RESULT = e; :}
      | assignment:a                    {: RESULT = a; :}
      | varOrNumber:n                   {: RESULT = n; :}
      | prePostIncrDecr:n               {: RESULT = n; :}
      | casting:n                       {: RESULT = n; :}
      ;

assignment ::= IDENT:i ASIG exp:e 	    	            {: RESULT = printer.assignment(symTable.lookUp(i), e); :}
             | IDENT:i AC exp:idx CC ASIG exp:e         {: RESULT = printer.assignment(symTable.lookUp(i), idx, e); :}
             | IDENT:i ASIG ALL listaExp:l CLL          {: RESULT = printer.arrayInit(i, l); :}
             ;

varOrNumber ::= variable:v              {: RESULT = v; :}
              | number:n                {: RESULT = n; :}
              ;

variable ::= IDENT:i				    {: RESULT = symTable.lookUp(i); :}
           | IDENT:i AC exp:idx CC      {: RESULT = printer.loadArray(symTable.lookUp(i), idx); :}
           ;

number ::= ENTERO:n                     {: RESULT = n; :}
         | REAL:n                       {: RESULT = n; :}
         ;

    // PRE-POST INCREMENT/DECREMENT
prePostIncrDecr ::= incrDecrOp:op IDENT:i       {: RESULT = printer.preIncrDecr(symTable.lookUp(i), op); :} %prec PREINCR
                  | IDENT:i incrDecrOp:op       {: RESULT = printer.postIncrDecr(symTable.lookUp(i), op); :}
                  | error                       {:  :}
                  ;

incrDecrOp ::= INCR					{: RESULT = "++"; :}
		     | DECR					{: RESULT = "--"; :}
		     ;

    // Explicit CASTING
casting ::= AP INT CP exp:e			{: RESULT = printer.casting(e, Occurrence.INT); :}
          | AP FLOAT CP
            varOrNumber:n1 			{: RESULT = printer.casting(n1, Occurrence.FLOAT); :}
            DIV varOrNumber:n2		{: Object e2 = printer.casting(n2, Occurrence.FLOAT);
                                       RESULT = printer.tern(RESULT, Printer.DIV, e2);
                                    :}
          ;

cond ::= exp:e1 EQ exp:e2		    {: RESULT = printer.condition(e1, Condition.EQ, e2); :}
       | exp:e1 NEQ exp:e2		    {: RESULT = printer.condition(e1, Condition.NEQ, e2); :}
       | exp:e1 LOW exp:e2		    {: RESULT = printer.condition(e1, Condition.LOW, e2); :}
       | exp:e1 LOE exp:e2		    {: RESULT = printer.condition(e1, Condition.LOE, e2); :}
       | exp:e1 GRE exp:e2		    {: RESULT = printer.condition(e1, Condition.GRE, e2); :}
       | exp:e1 GOE exp:e2		    {: RESULT = printer.condition(e1, Condition.GOE, e2); :}
       | NOT cond:c1			    {: RESULT = new Condition();
					                   RESULT.trueTag = c1.falseTag;
					                   RESULT.falseTag = c1.trueTag;
					                :}
       | cond:c1 AND 			    {: printer.label(c1.trueTag); :}
	     cond:c2  			        {: printer.label(c1.falseTag);
					                   printer.goTo(c2.trueTag);
					                   RESULT = c2;
					                :}
       | cond:c1 OR			        {: printer.label(c1.falseTag); :}
 	     cond:c2  			        {: printer.label(c1.trueTag);
					                   printer.goTo(c2.falseTag);
					                   RESULT = c2;
					                :}
       | AP cond:c1 CP			    {: RESULT = c1; :}
       ;


// LOOPS and FLOW CONTROLS

    // IF [ELSE]
ifElseSent ::= IF:endIf             {: :}
               AP cond:c CP		    {: printer.label(c.trueTag); :}
               sent				    {: printer.goTo(endIf);
					   				   printer.label(c.falseTag);
									:}
               elsePart             {: printer.label(endIf); :}
               ;

elsePart ::= ELSE sent
       |
       ;

    // WHILE loop
whileLoop ::= WHILE:whileTag		{: printer.label(whileTag); :}
              AP cond:c CP   		{: printer.label(c.falseTag); :}
              sent				    {: printer.goTo(whileTag);
                                       printer.goTo(c.trueTag);
                                    :}
                ;

    // DO WHILE
doWhileLoop ::= DO:doTag       		{: printer.label(doTag); :}
                sent                {: :}
                WHILE AP cond:c CP  {: :}
                PYC		            {: printer.label(c.trueTag);
                                       printer.goTo(doTag);
                                       printer.label(c.falseTag);
                                    :}
                ;

    // FOR loop
forLoop ::= FOR:forTag
	        AP exp:e1			    {: printer.label(forTag); :}
	        PYC cond:c PYC			{: RESULT = Yylex.newTag();
					                   printer.label(RESULT.toString());
                                    :}
	        exp:e2				    {: printer.goTo(forTag);
					                   printer.label(c.trueTag);
					                :}
	        CP sent			        {: printer.goTo(RESULT.toString());
					                   printer.label(c.falseTag);
					                :}
            ;


   // FOR IN
forIn ::= FOR:forTag variable:i         {: :}
          IN arrayPart:arr DO           {: RESULT = printer.forIn(i, forTag, arr); :}
          sent                          {: printer.goTo(forTag);
                                           printer.label(((Condition) RESULT).falseTag);
                                        :}
        ;

arrayPart ::= IDENT:arr             {: RESULT = arr; :}
            | ALL listaExp:l CLL    {: RESULT = l; :}
            ;